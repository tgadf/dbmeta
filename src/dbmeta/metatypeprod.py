""" Base Class For MetaData Type Creation """__all__ = ["MetaTypeProducer"]from pandas import DataFrame, concatclass MetaTypeProducer:    def __repr__(self):        return f"MetaProducerBase(metatype={self.metatype}, columns={self.columns})"            def __init__(self, metatype: str, rules: dict, **kwargs):        self.verbose = kwargs.get('verbose', False)        assert isinstance(metatype, str), f"metatype [{metatype}] is not a str"        self.metatype = metatype        assert isinstance(rules, dict), f"rules [{rules}] is not a dict"        columns = rules.get('Columns')        assert isinstance(columns, list), f"Columns [{columns}] is not a list"        self.columns = {}        for column in columns:            assert isinstance(rules.get(column), list), f"Rules does not have a [{column}] key"            self.columns[column] = rules[column]            ###########################################################################    # Utility Functions    ###########################################################################    def getDictData(self, colData, key):        retval = colData.get(key) if isinstance(colData, dict) else None        return retval        ###########################################################################    # General MetaData    ###########################################################################    def getMetaData(self, modValData: DataFrame) -> 'DataFrame':        assert isinstance(modValData, DataFrame), f"ModValData [{type(modValData)}] is not a DataFrame object"                featureMapper = {}        for column, features in self.columns.items():            assert column in modValData.columns, f"ModValData does not have column [{column}]: {modValData.columns}"            featureMapper[column] = {}            for feature in features:                assert isinstance(feature, (str, tuple)), f"column data [{column}] must be str/tuple"                if isinstance(feature, str):                    featureMapper[column][feature] = None                if isinstance(feature, tuple):                    assert len(feature) == 2, f"column data tuple [{feature}] be of len == 2"                    assert callable(feature[1]), f"function [{feature[1]}] is not callable"                    featureMapper[column][feature[0]] = feature[1]        colData = {}        for column, features in featureMapper.items():            for feature, mapper in features.items():                colData[feature] = modValData[column].apply(lambda coldata: self.getDictData(coldata, feature))                if mapper == len:                    colData[feature] = colData[feature].apply(lambda value: mapper(value) if isinstance(value, (dict, list)) else 0)                colData[feature].name = feature                        retval = concat(colData.values(), axis=1)        return retval